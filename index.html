<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="author" content="Luke Imhoff"/>
    <meta name="description"
          content="A JSONAPI 1.0 library fully-tested against all jsonapi.org examples.  The library generates JSONAPI errors documents whenever it encounters a malformed JSONAPI document, so that servers don't need to worry about JSONAPI format errors."/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Austin Elixir - Alembic</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <style>
      img.snippet {
        height: auto;
        vertical-align: text-top;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Austin Elixir</h1>
          <h2>Alembic</h2>
          <p>2016-06-20</p>
          <p>Author</p>
          <table>
            <tr>
              <th>
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                     version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px"
                                     viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
									<g>
										<path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                        <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                        <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                        <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                    </g>
                                </svg>
              </th>
              <td>limhoff@csd.org</td>
              <td>Kronic.Deth@gmail.com</td>
            </tr>
            <tr>
              <th>
                <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg"
                                     xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16"
                                     enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                               </svg>
              </th>
              <td>
                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
              </td>
              <td>
                <a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
              </td>
            </tr>
            <tr>
              <th>
                <svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
              </th>
              <td></td>
              <td>
                <a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
              </td>
            </tr>
          </table>
          <aside class="notes">
            <p>
              I am a Senior Software Engineer at Communication Service for the Deaf (CSD). CSD is fully
              remote for the development team and most of the non-profit outside the call centers. I work
              on Vineya, a market place and SaaS to allow the Deaf community to select their own American
              Sign Language (ASL) interpreter. The current, market place only version of Vineya is a Ruby
              application that was developed by I joining CSD. The SaaS version, under development,
              is a mix of Ruby applications and Elixir applications.
            </p>
            <p>
              In my free time I am the maintainer of IntelliJ Elixir, an Elixir plugin for JetBrains IDEs,
              like IntellIJ IDEA and Rubymine.
            </p>
          </aside>
        </section>
        <section>
          <h1>API</h1>
          <table>
            <thead>
              <tr>
                <th>Step</th>
                <th>JaSerializer</th>
                <td><em>Your Code</em></td>
                <td>Alembic</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>1</th>
                <td><code>ContentTypeNegotiation</code></td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <th>2</th>
                <td><code>Deserializer</code></td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <th>3</th>
                <td></td>
                <td><em>action</em></td>
                <td></td>
              </tr>
              <tr>
                <th>4</th>
                <td></td>
                <td></td>
                <td><code>Document.from_json</code></td>
              </tr>
              <tr>
                <th>5</th>
                <td></td>
                <td></td>
                <td><code>Document.to_params</code></td>
              </tr>
              <tr>
                <th>6</th>
                <td></td>
                <td></td>
                <td><code>ToParams.nested_to_foreign_keys</code></td>
              </tr>
              <tr>
                <th>7</th>
                <td></td>
                <td></td>
                <td><code>Fetch.from_params</code></td>
              </tr>
              <tr>
                <th>8</th>
                <td></td>
                <td></td>
                <td><code>Fetch.Includes.to_preloads</code></td>
              </tr>
              <tr>
                <th>9</th>
                <td><code>PhoenixView</code></td>
                <td></td>
                <td></td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">
            <p>
              When I announced the release of Alembic, there were multiple people wondering how it compared to
              JaSerializer, but for Vineya, we use JaSerializer with Alembic. We use JaSerializer's plugs to deal with
              the content-type and accept headers and to convert from JSONAPI's hyphenated keys to the underscored
              keys used by Ecto. Once inside each action, we use Alembic to (4) validate that the params are valid
              JSONAPI document; (5 & 6) convert to the params format used by Ecto.Changeset; and (8) to convert included
              relationships to association preloads before using JaSerializer again to render the view.
            </p>
            <p>
              When I started at CSD in November 2015, JaSerializer did not have Params.to_attributes, which was only
              added in April 2016, so params arrived at the Phoenix.Controller action, but there was no validation that
              the params were even structured as a proper JSONAPI document. We could manually pick out the data
              attributes and relationships that were needed for each controller and action, but that didn't seem right
              to me. My understanding of the purpose of JSONAPI was to make the encoding and decoding of resources
              more regular, so the code for any action across all controllers for JSONAPI resources should be the same.
              Furthermore, the JSONAPI spec outlines a format for errors and when they should be returned, so I knew
              that the error handling should be extractable to its own library, so it could get out of the business
              logic of each action.
            </p>
          </aside>
        </section>
        <section class="stack">
          <section>
            <h1>
              <a href="https://hexdocs.pm/alembic/2.1.0/Alembic.Document.html#from_json/2">
                <code>Document.from_json</code>
              </a>
            </h1>
            <img class="stretch" src="images/alembic/document/from-json.png"/>
            <aside class="notes">
              <p>
                Document.from_json takes in params, with underscored keys, in other words, the JSON, and an error
                template.
              </p>
              <p>
                The error template is necessary because the JSONAPI spec allows slightly different formats for the
                different actions. Importantly,
                <a href="https://github.com/C-S-D/alembic/blob/565ad837d4664075a88b37eb9f277e6d450904dd/lib/alembic/resource.ex#L1111-L1120">
                  Resource ids are optional if the "action" is :create when the "sender" is :client
                </a>. The error template also contains the source with a JSON pointer to where the JSON is located in
                a JSONAPI document. For Documents, that pointer is always the root pointer, or the empty string.
              </p>
            </aside>
          </section>
          <section>
            <h1>Empty Single Resource</h1>
            <img class="snippet" src="images/alembic/document/from-json/data/single/null/call.png" width="48%"/>
            <img class="snippet" src="images/alembic/document/from-json/data/single/null/return.png" width="48%"/>
            <aside class="notes">
              <p>
                An empty single resource can be represented with <code>"data": null</code> in encoded JSON, which would
                show up as <code>data: nil</code> in the json passed to from_json.
              </p>
              <p>
                Alembic isn't doing much here, it's turning the map into a struct and so the string "data" becomes the
                atom key data.
              </p>
              <p>
                In general, throughout Alembic, if a JSON object has a fixed set of keys, it became a struct while JSON
                objects with free-form keys remained maps with string keys. This prevent atom table exhaustion.
              </p>
            </aside>
          </section>
          <section>
            <h1>Present Single Resource</h1>
            <img class="snippet" src="images/alembic/document/from-json/data/single/resource/call.png" width="48%"/>
            <img class="snippet" src="images/alembic/document/from-json/data/single/resource/return.png" width="48%"/>
            <aside class="notes">
              <p>
                A present single resource gets more interesting, the data becomes a nested Resource struct.
              </p>
            </aside>
          </section>
          <section>
            <h1>Present Single Resource Identifier</h1>
            <img class="snippet" src="images/alembic/document/from-json/data/single/resource-identifier/call.png"
                 width="48%"/>
            <img class="snippet" src="images/alembic/document/from-json/data/single/resource-identifier/return.png"
                 width="48%"/>
            <aside class="notes">
              <p>
                In addition to Resources, JSONAPI supports Resource Identifiers, which only have a "type" and "id".
              </p>
              <p>
                There are no type hints of whether the top-level "data" is a Resource or Resource Identifier when
                converting the json map, so the JSON object in "data" is treated as a Resource if "attributes" or
                "relationships" is present, otherwise it is a Resource Identifier.
              </p>

            </aside>
          </section>
          <section>
            <h1>Present Collection</h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/from-json/data/collection/resources/call.png"
                   width="48%"/>
              <img class="snippet" src="images/alembic/document/from-json/data/collection/resources/return.png"
                   width="48%"/>
            </div>
            <aside class="notes">
              <p>
                "data" can also be a collection of resources, such as for as has-many relationship or the return from
                an index.
              </p>
              <p>
                Just like singletons, collections can be made of either Resources or Resource Identifiers.
              </p>
            </aside>
          </section>
          <section>
            <h1>Relationships and Includes</h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/from-json/data/relationships-and-includes/call.png"
                   width="48%"/>
              <img class="snippet" src="images/alembic/document/from-json/data/relationships-and-includes/return.png"
                   width="48%"/>
            </div>
            <aside class="notes">
              <p>
                The JSONAPI spec considers foreign keys an implementation detail and expressly states that they
                shouldn't be included in the attributes of a resource, so when you want to represent a foreign key,
                you make a relationship with a Resource Identifier.
              </p>
              <p>
                You can side-load relationships to any depth (assuming the server supports the relationship path) and
                the resources will be elements of the includes.
              </p>
              <p>
                Notice how most containers are structs with atom keys, but the relationships of a Resource is a map
                with string keys because the names are not predefined by the JSONAPI spec.
              </p>
            </aside>
          </section>
          <section>
            <h1>Errors</h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/from-json/incomplete/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/document/from-json/incomplete/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                Ok, that's great, Alembic can parse JSON into structs, but that doesn't buy us much. What we want is
                for Alembic to automatically handle error reporting, so if the json is not a valid JSONAPI document,
                instead of returning <code>{:ok, Document.t}</code>, Alembic will return
                <code>{:error, Document.t}</code>
              </p>
              <p>
                If there's an error, how can Alembic return a Document still? It's not a partial Document containing
                only the valid parts of the JSON, but instead a JSONAPI error document that can be re-encoded and sent
                back to the sender.
              </p>
              <p>
                The format of detail and meta isn't that specific in the JSONAPI spec, but in general Alembic tries to
                include machine parsable presentations of anything from details in meta, so that you can construct your
                own error messages if you don't like the detail message.
              </p>
            </aside>
          </section>
          <section>
            <h1>Nested Errors</h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/from-json/errors/error/call.png" width="48%">
              <img class="snippet" src="images/alembic/document/from-json/errors/error/return.png" width="48%">
            </div>
            <aside class="notes">
              <p>
                Alembic doesn't just detect errors in the top-level keys of the JSONAPI document, but in all the nested
                JSON objects that are defined by the spec.
              </p>
              <p>
                When an error is found in a nested part of the Document, the source pointer shows which element has
                the error. The source pointer is a JSON Pointer, defined in RFC 6901.
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <h1>FromJson.from_json</h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/from-json/from-json/callback.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                Alembic can generate the nested JSON pointers due from_json being a behaviour callback in
                Alembic.FromJson.
              </p>
              <p>
                All the nested JSON objects in documents have modules (Error, Link, Links, Meta, Relationship,
                Relationships, Resource, ResourceIdentifier, ResourceLinkage, and Source) that implement the FromJson
                behavior.
              </p>
            </aside>
          </section>
          <section>
            <h1><code>Error.descend</code></h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/error/descend/call.png" width="48%">
              <img class="snippet" src="images/alembic/error/descend/return.png" width="48%">
            </div>
            <aside class="notes">
              <p>
                Because each nested JSON object has a module, converting json to an Alembic.Document struct is a matter
                of each level converting its children by passing an error template with that child's source pointer.
              </p>
              <p>
                The child's error template is made using Error.descend
              </p>
            </aside>
          </section>
          <section>
            <h1><code>FromJson.merge</code></h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/from-json/merge/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/from-json/merge/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                The final piece of the error handling is being able to report multiple errors instead of just the first
                error. This isn't required by the JSONAPI spec, it says "A server MAY choose to stop processing as soon
                as a problem is encountered, or it MAY continue processing and encounter multiple problems", but I
                wanted all errors in one request to be available, so users don't need multiple round trips to fix
                errors.
              </p>
            </aside>
          </section>
          <section>
            <h1><code>FromJson.reduce</code></h1>
            <div class="stretch">
              <img class="snippet" src="images/alembic/from-json/reduce/call.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                FromJson.reduce is the enumerable version of FromJson.merge
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/create.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                So, how do we use this nice error handling in our controllers? After JaSerializer.Deserializer has
                converted the hyphenated params to underscores, the action gets the params, and uses those as the json
                for Document.from_json.
              </p>
              <p>
                In our InterpreterServer app for Vineya, I've made a module, InterpreterServer.Controller.Ecto, that has
                common actions for each of the REST actions required by JSONAPI, so for the create action, it calls
                IntepreterServer.Controller.Ecto.create.
              </p>
              <p>
                The general structure of the controller functions uses a happy path <code>with</code> in action
                function and then the sad path is handled by each method being called generating the error response.
                This effectively works like halting the Plug.Conn, but I don't have to setup guard clauses at the top
                of the controller to have plugs used for only one action.
              </p>
              <p>
                <code>valid_create_changeset</code> and <code>preloads_from_include_param</code> both use Alembic, so
                we'll focus on those functions.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/valid-create-changeset.png"
                   width="100%"/>
              <img class="snippet" src="images/interpreter-server/controller/ecto/create-changeset.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                <code>valid_create_changeset</code> calls <code>create_changeset</code> and
                <code>create_changeset</code> calls <code>document_from_json</code>.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/document-from-json.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                <code>document_from_json</code> calls Alembic.Document.from_json with the action name and using the
                <code>with</code> to handle the sad path of rendering the error.
              </p>
              <p>
                <code>document_from_json</code> is only called for <code>create</code> and <code>update</code> actions,
                which match the names used in the JSONAPI spec, but there are other actions that don't match exactly.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/from-json/action.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                The JSONAPI spec doesn't differentiate the action for index or show and instead calls that fetch.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/create-changeset.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                When <code>document_from_json</code> doesn't encounter an error, <code>create_changeset</code>'s
                <code>with</code> passes the Document to Document.to_params and then ensures <code>belongs_to</code>
                associations will insert correctly using ToParams.nested_to_foreign_keys.
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/to-params.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                JSONAPI Document is at most two levels deep: The Resource(s) in data and then any direct or indirect
                relationships are grouped together in <code>included</code>, but the nested params format has no fixed
                depth, so <code>to_params</code> needs to pass a lookup table keyed by <code>type</code> and
                <code>id</code>.
              </p>
              <p>
                However, the lookup table wasn't enough because the JSONAPI allows ResourceIdentifiers, or effectively
                pointers, AND it represents <code>has_one</code> and <code>belongs_to</code> associations the same
                way: as to-one relationships, so when both the Resource with the <code>belongs_to</code> association
                and the related resource with the <code>has_one</code> are included in a JSONAPI document, you get
                circular references in in the ResourceIdentifiers in the relationships.
                <code>converted_by_id_by_type</code> prevents the circular references from leading to infinite
                recursion by tracking the <code>{type, id}</code> pairs that have already been converted from
                JSONAPI to nested params.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/to-params/to-params-3.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                If a <code>type</code> and <code>id</code> have already been seen, the conversion can't return nothing
                because that would make it looks like the nested association is <code>nil</code>, so instead, if the
                <code>type</code> and <code>id</code> is in <code>converted_by_id_by_type</code>, just the primary
                key is included.
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/create-changeset.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                The <code>ToParams.to_params</code> behaviour only nests params, it does not transform nested params
                to the format needed for Ecto.Changeset.cast because <code>to_params</code> is not passed the
                Ecto.Schema modules. This is a deliberate design choice, so that the behaviour doesn't have a
                dependency on Ecto and it allows to reduce the number of arguments passed down to the child
                <code>to_params</code> calls.
              </p>
              <p>
                So, once Document.to_params returns the nested params, along with the primary Ecto.Schema module is
                passed to ToParams.nested_to_foreign_keys.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/to-params/nested-to-foreign-keys/present/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/to-params/nested-to-foreign-keys/present/return.png"
                   width="48%"/>
            </div>
            <aside class="notes">
              <p>
                When <code>nested_to_foreign_keys</code> converts a nested primary key to a foreign key, it removes
                the nested params from the returned map.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/to-params/nested-to-foreign-keys/nil/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/to-params/nested-to-foreign-keys/nil/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                When the nested params are <code>nil</code>, the foreign key has to be set to <code>nil</code> to
                distinguish the case where it was just not included.
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/create.png" width="100%">
            </div>
            <aside class="notes">
              <p>
                We have a Changeset for create, but once created, we may want to return some associations as included
                relationships.
              </p>
              <p>
                I call <code>preloads_from_include_param</code> before calling <code>mutate_repo</code> because
                the preloads could be malformed and I don't want errors in the input preventing me from rendering a
                proper response after I've changed the Repo because that could lead the caller to believe the Repo
                did not change when it did.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/controller/ecto/preloads-from-include-param.png"
                   width="100%"/>
            </div>
            <aside class="notes">
              <p>
                <code>Fetch.from_params</code> can't error out because there is no validation on the include parameter:
                the allowed relationships aren't checked until <code>Fetch.to_query</code>.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/fetch/to-query/error/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/fetch/to-query/error/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                If a relationship path, here <code>"secret"</code> isn't mapped to <code>preloads</code>, then an error
                is returned, so that callers don't have wonder why resources aren't being included. This can be very
                important when you explicitly decide not to include an association in the list of includable
                relationships.
              </p>
            </aside>
          </section>
          <section>
            <h1>API</h1>
            <table>
              <thead>
                <tr>
                  <th>Step</th>
                  <th>JaSerializer</th>
                  <td><em>Your Code</em></td>
                  <td>Alembic</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>1</th>
                  <td><code>ContentTypeNegotiation</code></td>
                  <td></td>
                  <td></td>
                </tr>
                <tr>
                  <th>2</th>
                  <td><code>Deserializer</code></td>
                  <td></td>
                  <td></td>
                </tr>
                <tr>
                  <th>3</th>
                  <td></td>
                  <td><em>action</em></td>
                  <td></td>
                </tr>
                <tr>
                  <th>4</th>
                  <td></td>
                  <td></td>
                  <td><code>Document.from_json</code></td>
                </tr>
                <tr>
                  <th>5</th>
                  <td></td>
                  <td></td>
                  <td><code>Document.to_params</code></td>
                </tr>
                <tr>
                  <th>6</th>
                  <td></td>
                  <td></td>
                  <td><code>ToParams.nested_to_foreign_keys</code></td>
                </tr>
                <tr>
                  <th>7</th>
                  <td></td>
                  <td></td>
                  <td><code>Fetch.from_params</code></td>
                </tr>
                <tr>
                  <th>8</th>
                  <td></td>
                  <td></td>
                  <td><code>Fetch.Includes.to_preloads</code></td>
                </tr>
                <tr>
                  <th>9</th>
                  <td><code>PhoenixView</code></td>
                  <td></td>
                  <td></td>
                </tr>
              </tbody>
            </table>
            <aside class="notes">
              <p>
                With a valid changeset and preloads, we can change the database, knowing that we'll be able to
                render the response in the format requested by the caller.
              </p>
              <p>
                The last step is rendering with a JaSerializer.PhoenixView.
              </p>
            </aside>
          </section>
        </section>
        <section class="stack">
          <section>
            <h1>Client</h1>
            <table>
              <thead>
                <tr>
                  <th>Step</th>
                  <td>Alembic</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th>
                  </td>
                </tr>
              </tbody>
            </table>
            <aside class="notes">
              <p>
                So far, I've shown Alembic working as the server, but Alembic can also be used in a client.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/rpc/client/generic/result-to-document.png"
                   width="100%"/>
            </div>
            <aside class="notes">
              <p>
                In addition to using Alembic for our controllers that interface with Ember, we put JSONAPI inside
                of JSONRPC and use that to communicate with Ruby applications over RabbitMQ. Our Elixir application
                has both RPC servers for the resources it owns and RPC clients to getting resources that the Ruby
                applications own.
              </p>
              <p>
                When the JSONRPC response comes back, it has a result field, that field is the <code>result</code>
                argument to <code>result_to_document</code>.
              </p>
              <p>
                <code>Api.deserialize_keys</code> does the same as JaSerializer.Deserializer, but isn't dependent on
                the argument being a Plug.Conn.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/api/deserialize-keys.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                Internally, <code>Api.deserialize_keys</code> uses the same formatting functions as
                JaSerialier.Deserializer: <code>JaSerializer.ParamParser.Utils.format_keys</code>
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/interpreter-server/rpc/client/generic/reply.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                <code>result_to_document</code>'s Document is used in <code>reply</code>, which formats the GenServer
                reply.
              </p>
              <p>
                As part of that formatting, I wanted the RPC client to return a nested Ecto.Schema struct that would
                look just like the return from Ecto.Repo calls, so Document.to_ecto_schema does that conversion.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/to-ecto-schema/nil/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/document/to-ecto-schema/nil/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                When there is <code>nil</code> data in JSONAPI, it becomes <code>nil</code> for the Ecto.Schema struct.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/to-ecto-schema/single/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/document/to-ecto-schema/single/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                When there is a single Resource in "data", it becomes an Ecto.Schema struct corresponding to that type
                using the ecto_schema_by_type map passed to <code>to_ecto_schema</code>.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/document/to-ecto-schema/relationship/call.png" width="48%"/>
              <img class="snippet" src="images/alembic/document/to-ecto-schema/relationship/return.png" width="48%"/>
            </div>
            <aside class="notes">
              <p>
                When there are relationships, they get attached to the struct using the associations.
              </p>
            </aside>
          </section>
          <section>
            <table>
              <thead>
                <tr>
                  <th>JSONAPI</th>
                  <th>Ecto.Schema</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>attributes</td>
                  <td>fields</td>
                </tr>
                <tr>
                  <td>relationships</td>
                  <td>associations</td>
                </tr>
              </tbody>
            </table>
            <aside class="notes">
              <p>
                This may seem like I'm overly tying the relationships to the associations, but none of this code
                cares that an Ecto.Repo exists. The Ecto.Schema modules are only used as a convenient way to
                declare the casting rules for the attributes and relationships, mapping JSONAPI Resource attributes to
                Ecto.Schema fields and relationships to associations. The Ecto.Schema modules don't have to be backed
                by a database table and aren't for our usage of RPC clients.
              </p>
              <p>
                It so happens that for our API controllers, the Ecto.Schema module used to cast the JSONAPI to structs
                is the same as the database table, but that doesn't have to be the case and is only that way because
                none of our JSONAPI resources are composite views of database tables.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/to-ecto-schema/to-ecto-schema.png" width="100%"/>
              <img class="snippet" src="images/alembic/to-ecto-schema/put-named-association.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                Document.to_ecto_schema eventually calls ToEctoSchema.to_ecto_schema, which uses Ecto.Changeset.cast
                to apply the casting rules defined by the Ecto.Schema module <code>field</code>s. It does not use
                changeset, because for the use case of a Client, there is no validation of the attribute and
                associations because whatever the Server sent is the truth.
              </p>
              <p>
                Because <code>to_ecto_schema</code> uses only <code>cast</code> and <code>__schema__</code>, which
                are available to any module <code>us</code>ing Ecto.Schema's schema DSL, there's no new DSLs needed to
                use an Ecto.Schema module for to_ecto_schema.
              </p>
              <p>
                The <code>to_string</code> in <code>put_named_association</code> is the code that cements that
                relationship name (after prior reformatting from hyphenated to underscored) match association names.
                If one wanted to make them different, the <code>to_string</code> could be changed to a transformation
                function that is passed in. PRs welcome.
              </p>
            </aside>
          </section>
          <section>
            <div class="stretch">
              <img class="snippet" src="images/alembic/to-ecto-schema/put-association.png" width="100%"/>
            </div>
            <aside class="notes">
              <p>
                <code>put_association</code> handles the differences between different types of associations and starts
                recursively handling indirect relationships by calling <code>to_ecto_schema</code> on each of the
                associated params.
              </p>
            </aside>
          </section>
        </section>
        <section>
          <table>
            <thead>
              <tr>
                <th></th>
                <th>Client</th>
                <th>Server</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>API</th>
                <td>&#10003;</td>
                <td>&#10003;</td>
              </tr>
              <tr>
                <th>RPC</th>
                <td>&#10003;</td>
                <td>&#10003;</td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">
            <p>
              With the available conversion functions provided by Alembic, we are able to use it for clients and servers
              and for API and RPC. It can work with Plugs, such as those from JaSerializer, but does not require a
              Plug.Conn to be avalable. It leaves the casting and associations of Ecto, without the need for
              access to a database through an Ecto.Repo.
            </p>
          </aside>
        </section>
      </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          {src: 'plugin/markdown/marked.js'},
          {src: 'plugin/markdown/markdown.js'},
          {src: 'plugin/notes/notes.js', async: true},
          {
            src: 'plugin/highlight/highlight.js', async: true, callback: function () {
            hljs.initHighlightingOnLoad();
          }
          }
        ],
        height: 1280,
        history: true,
        slideNumber: 'c / t',
        width: 2048
      });
    </script>
  </body>
</html>
